{"version":3,"sources":["../src/bytes.ts","../src/codec.ts","../src/combine-codec.ts","../src/add-codec-sentinel.ts","../src/assertions.ts","../src/add-codec-size-prefix.ts","../src/fix-codec-size.ts","../src/offset-codec.ts","../src/resize-codec.ts","../src/pad-codec.ts","../src/reverse-codec.ts","../src/transform-codec.ts"],"names":["SolanaError"],"mappings":"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","file":"index.native.mjs","sourcesContent":["import { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Concatenates an array of `Uint8Array`s into a single `Uint8Array`.\n * Reuses the original byte array when applicable.\n *\n * @param byteArrays - The array of byte arrays to concatenate.\n *\n * @example\n * ```ts\n * const bytes1 = new Uint8Array([0x01, 0x02]);\n * const bytes2 = new Uint8Array([]);\n * const bytes3 = new Uint8Array([0x03, 0x04]);\n * const bytes = mergeBytes([bytes1, bytes2, bytes3]);\n * //    ^ [0x01, 0x02, 0x03, 0x04]\n * ```\n */\nexport const mergeBytes = (byteArrays: Uint8Array[]): Uint8Array => {\n    const nonEmptyByteArrays = byteArrays.filter(arr => arr.length);\n    if (nonEmptyByteArrays.length === 0) {\n        return byteArrays.length ? byteArrays[0] : new Uint8Array();\n    }\n\n    if (nonEmptyByteArrays.length === 1) {\n        return nonEmptyByteArrays[0];\n    }\n\n    const totalLength = nonEmptyByteArrays.reduce((total, arr) => total + arr.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    nonEmptyByteArrays.forEach(arr => {\n        result.set(arr, offset);\n        offset += arr.length;\n    });\n    return result;\n};\n\n/**\n * Pads a `Uint8Array` with zeroes to the specified length.\n * If the array is longer than the specified length, it is returned as-is.\n *\n * @param bytes - The byte array to pad.\n * @param length - The desired length of the byte array.\n *\n * @example\n * Adds zeroes to the end of the byte array to reach the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const paddedBytes = padBytes(bytes, 4);\n * //    ^ [0x01, 0x02, 0x00, 0x00]\n * ```\n *\n * @example\n * Returns the original byte array if it is already at the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const paddedBytes = padBytes(bytes, 2);\n * // bytes === paddedBytes\n * ```\n */\nexport const padBytes = (bytes: ReadonlyUint8Array | Uint8Array, length: number): ReadonlyUint8Array | Uint8Array => {\n    if (bytes.length >= length) return bytes;\n    const paddedBytes = new Uint8Array(length).fill(0);\n    paddedBytes.set(bytes);\n    return paddedBytes;\n};\n\n/**\n * Fixes a `Uint8Array` to the specified length.\n * If the array is longer than the specified length, it is truncated.\n * If the array is shorter than the specified length, it is padded with zeroes.\n *\n * @param bytes - The byte array to truncate or pad.\n * @param length - The desired length of the byte array.\n *\n * @example\n * Truncates the byte array to the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03, 0x04]);\n * const fixedBytes = fixBytes(bytes, 2);\n * //    ^ [0x01, 0x02]\n * ```\n *\n * @example\n * Adds zeroes to the end of the byte array to reach the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const fixedBytes = fixBytes(bytes, 4);\n * //    ^ [0x01, 0x02, 0x00, 0x00]\n * ```\n *\n * @example\n * Returns the original byte array if it is already at the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const fixedBytes = fixBytes(bytes, 2);\n * // bytes === fixedBytes\n * ```\n */\nexport const fixBytes = (bytes: ReadonlyUint8Array | Uint8Array, length: number): ReadonlyUint8Array | Uint8Array =>\n    padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\n\n/**\n * Returns true if and only if the provided `data` byte array contains\n * the provided `bytes` byte array at the specified `offset`.\n *\n * @param data - The byte sequence to search for.\n * @param bytes - The byte array in which to search for `data`.\n * @param offset - The position in `bytes` where the search begins.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03, 0x04]);\n * const data = new Uint8Array([0x02, 0x03]);\n * containsBytes(bytes, data, 1); // true\n * containsBytes(bytes, data, 2); // false\n * ```\n */\nexport function containsBytes(\n    data: ReadonlyUint8Array | Uint8Array,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset: number,\n): boolean {\n    const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);\n    if (slice.length !== bytes.length) return false;\n    return bytes.every((b, i) => b === slice[i]);\n}\n","import {\n    SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Defines an offset in bytes.\n */\nexport type Offset = number;\n\n/**\n * An object that can encode a value of type {@link TFrom} into a {@link ReadonlyUint8Array}.\n *\n * This is a common interface for {@link FixedSizeEncoder} and {@link VariableSizeEncoder}.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n *\n * @see {@link FixedSizeEncoder}\n * @see {@link VariableSizeEncoder}\n */\ntype BaseEncoder<TFrom> = {\n    /** Encode the provided value and return the encoded bytes directly. */\n    readonly encode: (value: TFrom) => ReadonlyUint8Array;\n    /**\n     * Writes the encoded value into the provided byte array at the given offset.\n     * Returns the offset of the next byte after the encoded value.\n     */\n    readonly write: (value: TFrom, bytes: Uint8Array, offset: Offset) => Offset;\n};\n\n/**\n * An object that can encode a value of type {@link TFrom} into a fixed-size {@link ReadonlyUint8Array}.\n *\n * See {@link Encoder} to learn more about creating and composing encoders.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const encoder: FixedSizeEncoder<number, 4>;\n * const bytes = encoder.encode(42);\n * const size = encoder.fixedSize; // 4\n * ```\n *\n * @see {@link Encoder}\n * @see {@link VariableSizeEncoder}\n */\nexport type FixedSizeEncoder<TFrom, TSize extends number = number> = BaseEncoder<TFrom> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\n/**\n * An object that can encode a value of type {@link TFrom} into a variable-size {@link ReadonlyUint8Array}.\n *\n * See {@link Encoder} to learn more about creating and composing encoders.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n *\n * @example\n * ```ts\n * const encoder: VariableSizeEncoder<string>;\n * const bytes = encoder.encode('hello');\n * const size = encoder.getSizeFromValue('hello');\n * ```\n *\n * @see {@link Encoder}\n * @see {@link FixedSizeEncoder}\n */\nexport type VariableSizeEncoder<TFrom> = BaseEncoder<TFrom> & {\n    /** Returns the size of the encoded value in bytes for a given input. */\n    readonly getSizeFromValue: (value: TFrom) => number;\n    /** The maximum possible size of an encoded value in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can encode a value of type {@link TFrom} into a {@link ReadonlyUint8Array}.\n *\n * An `Encoder` can be either:\n * - A {@link FixedSizeEncoder}, where all encoded values have the same fixed size.\n * - A {@link VariableSizeEncoder}, where encoded values can vary in size.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @example\n * Encoding a value into a new byte array.\n * ```ts\n * const encoder: Encoder<string>;\n * const bytes = encoder.encode('hello');\n * ```\n *\n * @example\n * Writing the encoded value into an existing byte array.\n * ```ts\n * const encoder: Encoder<string>;\n * const bytes = new Uint8Array(100);\n * const nextOffset = encoder.write('hello', bytes, 20);\n * ```\n *\n * @remarks\n * You may create `Encoders` manually using the {@link createEncoder} function but it is more common\n * to compose multiple `Encoders` together using the various helpers of the `@solana/codecs` package.\n *\n * For instance, here's how you might create an `Encoder` for a `Person` object type that contains\n * a `name` string and an `age` number:\n *\n * ```ts\n * import { getStructEncoder, addEncoderSizePrefix, getUtf8Encoder, getU32Encoder } from '@solana/codecs';\n *\n * type Person = { name: string; age: number };\n * const getPersonEncoder = (): Encoder<Person> =>\n *     getStructEncoder([\n *         ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n *         ['age', getU32Encoder()],\n *     ]);\n * ```\n *\n * Note that composed `Encoder` types are clever enough to understand whether\n * they are fixed-size or variable-size. In the example above, `getU32Encoder()` is\n * a fixed-size encoder, while `addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())`\n * is a variable-size encoder. This makes the final `Person` encoder a variable-size encoder.\n *\n * @see {@link FixedSizeEncoder}\n * @see {@link VariableSizeEncoder}\n * @see {@link createEncoder}\n */\nexport type Encoder<TFrom> = FixedSizeEncoder<TFrom> | VariableSizeEncoder<TFrom>;\n\n/**\n * An object that can decode a byte array into a value of type {@link TTo}.\n *\n * This is a common interface for {@link FixedSizeDecoder} and {@link VariableSizeDecoder}.\n *\n * @interface\n * @typeParam TTo - The type of the decoded value.\n *\n * @see {@link FixedSizeDecoder}\n * @see {@link VariableSizeDecoder}\n */\ntype BaseDecoder<TTo> = {\n    /** Decodes the provided byte array at the given offset (or zero) and returns the value directly. */\n    readonly decode: (bytes: ReadonlyUint8Array | Uint8Array, offset?: Offset) => TTo;\n    /**\n     * Reads the encoded value from the provided byte array at the given offset.\n     * Returns the decoded value and the offset of the next byte after the encoded value.\n     */\n    readonly read: (bytes: ReadonlyUint8Array | Uint8Array, offset: Offset) => [TTo, Offset];\n};\n\n/**\n * An object that can decode a fixed-size byte array into a value of type {@link TTo}.\n *\n * See {@link Decoder} to learn more about creating and composing decoders.\n *\n * @interface\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const decoder: FixedSizeDecoder<number, 4>;\n * const value = decoder.decode(bytes);\n * const size = decoder.fixedSize; // 4\n * ```\n *\n * @see {@link Decoder}\n * @see {@link VariableSizeDecoder}\n */\nexport type FixedSizeDecoder<TTo, TSize extends number = number> = BaseDecoder<TTo> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\n/**\n * An object that can decode a variable-size byte array into a value of type {@link TTo}.\n *\n * See {@link Decoder} to learn more about creating and composing decoders.\n *\n * @interface\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * ```ts\n * const decoder: VariableSizeDecoder<number>;\n * const value = decoder.decode(bytes);\n * ```\n *\n * @see {@link Decoder}\n * @see {@link VariableSizeDecoder}\n */\nexport type VariableSizeDecoder<TTo> = BaseDecoder<TTo> & {\n    /** The maximum possible size of an encoded value in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can decode a byte array into a value of type {@link TTo}.\n *\n * An `Decoder` can be either:\n * - A {@link FixedSizeDecoder}, where all byte arrays have the same fixed size.\n * - A {@link VariableSizeDecoder}, where byte arrays can vary in size.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * Getting the decoded value from a byte array.\n * ```ts\n * const decoder: Decoder<string>;\n * const value = decoder.decode(bytes);\n * ```\n *\n * @example\n * Reading the decoded value from a byte array at a specific offset\n * and getting the offset of the next byte to read.\n * ```ts\n * const decoder: Decoder<string>;\n * const [value, nextOffset] = decoder.read('hello', bytes, 20);\n * ```\n *\n * @remarks\n * You may create `Decoders` manually using the {@link createDecoder} function but it is more common\n * to compose multiple `Decoders` together using the various helpers of the `@solana/codecs` package.\n *\n * For instance, here's how you might create an `Decoder` for a `Person` object type that contains\n * a `name` string and an `age` number:\n *\n * ```ts\n * import { getStructDecoder, addDecoderSizePrefix, getUtf8Decoder, getU32Decoder } from '@solana/codecs';\n *\n * type Person = { name: string; age: number };\n * const getPersonDecoder = (): Decoder<Person> =>\n *     getStructDecoder([\n *         ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n *         ['age', getU32Decoder()],\n *     ]);\n * ```\n *\n * Note that composed `Decoder` types are clever enough to understand whether\n * they are fixed-size or variable-size. In the example above, `getU32Decoder()` is\n * a fixed-size decoder, while `addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())`\n * is a variable-size decoder. This makes the final `Person` decoder a variable-size decoder.\n *\n * @see {@link FixedSizeDecoder}\n * @see {@link VariableSizeDecoder}\n * @see {@link createDecoder}\n */\nexport type Decoder<TTo> = FixedSizeDecoder<TTo> | VariableSizeDecoder<TTo>;\n\n/**\n * An object that can encode and decode a value to and from a fixed-size byte array.\n *\n * See {@link Codec} to learn more about creating and composing codecs.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const codec: FixedSizeCodec<number | bigint, bigint, 8>;\n * const bytes = codec.encode(42);\n * const value = codec.decode(bytes); // 42n\n * const size = codec.fixedSize; // 8\n * ```\n *\n * @see {@link Codec}\n * @see {@link VariableSizeCodec}\n */\nexport type FixedSizeCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number> = FixedSizeDecoder<\n    TTo,\n    TSize\n> &\n    FixedSizeEncoder<TFrom, TSize>;\n\n/**\n * An object that can encode and decode a value to and from a variable-size byte array.\n *\n * See {@link Codec} to learn more about creating and composing codecs.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * ```ts\n * const codec: VariableSizeCodec<number | bigint, bigint>;\n * const bytes = codec.encode(42);\n * const value = codec.decode(bytes); // 42n\n * const size = codec.getSizeFromValue(42);\n * ```\n *\n * @see {@link Codec}\n * @see {@link FixedSizeCodec}\n */\nexport type VariableSizeCodec<TFrom, TTo extends TFrom = TFrom> = VariableSizeDecoder<TTo> & VariableSizeEncoder<TFrom>;\n\n/**\n * An object that can encode and decode a value to and from a byte array.\n *\n * A `Codec` can be either:\n * - A {@link FixedSizeCodec}, where all encoded values have the same fixed size.\n * - A {@link VariableSizeCodec}, where encoded values can vary in size.\n *\n * @example\n * ```ts\n * const codec: Codec<string>;\n * const bytes = codec.encode('hello');\n * const value = codec.decode(bytes); // 'hello'\n * ```\n *\n * @remarks\n * For convenience, codecs can encode looser types than they decode.\n * That is, type {@link TFrom} can be a superset of type {@link TTo}.\n * For instance, a `Codec<bigint | number, bigint>` can encode both\n * `bigint` and `number` values, but will always decode to a `bigint`.\n *\n * ```ts\n * const codec: Codec<bigint | number, bigint>;\n * const bytes = codec.encode(42);\n * const value = codec.decode(bytes); // 42n\n * ```\n *\n * It is worth noting that codecs are the union of encoders and decoders.\n * This means that a `Codec<TFrom, TTo>` can be combined from an `Encoder<TFrom>`\n * and a `Decoder<TTo>` using the {@link combineCodec} function. This is particularly\n * useful for library authors who want to expose all three types of objects to their users.\n *\n * ```ts\n * const encoder: Encoder<bigint | number>;\n * const decoder: Decoder<bigint>;\n * const codec: Codec<bigint | number, bigint> = combineCodec(encoder, decoder);\n * ```\n *\n * Aside from combining encoders and decoders, codecs can also be created from scratch using\n * the {@link createCodec} function but it is more common to compose multiple codecs together\n * using the various helpers of the `@solana/codecs` package.\n *\n * For instance, here's how you might create a `Codec` for a `Person` object type that contains\n * a `name` string and an `age` number:\n *\n * ```ts\n * import { getStructCodec, addCodecSizePrefix, getUtf8Codec, getU32Codec } from '@solana/codecs';\n *\n * type Person = { name: string; age: number };\n * const getPersonCodec = (): Codec<Person> =>\n *     getStructCodec([\n *         ['name', addCodecSizePrefix(getUtf8Codec(), getU32Codec())],\n *         ['age', getU32Codec()],\n *     ]);\n * ```\n *\n * Note that composed `Codec` types are clever enough to understand whether\n * they are fixed-size or variable-size. In the example above, `getU32Codec()` is\n * a fixed-size codec, while `addCodecSizePrefix(getUtf8Codec(), getU32Codec())`\n * is a variable-size codec. This makes the final `Person` codec a variable-size codec.\n *\n * @see {@link FixedSizeCodec}\n * @see {@link VariableSizeCodec}\n * @see {@link combineCodec}\n * @see {@link createCodec}\n */\nexport type Codec<TFrom, TTo extends TFrom = TFrom> = FixedSizeCodec<TFrom, TTo> | VariableSizeCodec<TFrom, TTo>;\n\n/**\n * Gets the encoded size of a given value in bytes using the provided encoder.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @param value - The value to be encoded.\n * @param encoder - The encoder used to determine the encoded size.\n * @returns The size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const fixedSizeEncoder = { fixedSize: 4 };\n * getEncodedSize(123, fixedSizeEncoder); // Returns 4.\n *\n * const variableSizeEncoder = { getSizeFromValue: (value: string) => value.length };\n * getEncodedSize(\"hello\", variableSizeEncoder); // Returns 5.\n * ```\n *\n * @see {@link Encoder}\n */\nexport function getEncodedSize<TFrom>(\n    value: TFrom,\n    encoder: { fixedSize: number } | { getSizeFromValue: (value: TFrom) => number },\n): number {\n    return 'fixedSize' in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\n\n/**\n * Creates an `Encoder` by filling in the missing `encode` function using the provided `write` function and\n * either the `fixedSize` property (for {@link FixedSizeEncoder | FixedSizeEncoders}) or\n * the `getSizeFromValue` function (for {@link VariableSizeEncoder | VariableSizeEncoders}).\n *\n * Instead of manually implementing `encode`, this utility leverages the existing `write` function\n * and the size helpers to generate a complete encoder. The provided `encode` method will allocate\n * a new `Uint8Array` of the correct size and use `write` to populate it.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size encoders).\n *\n * @param encoder - An encoder object that implements `write`, but not `encode`.\n * - If the encoder has a `fixedSize` property, it is treated as a {@link FixedSizeEncoder}.\n * - Otherwise, it is treated as a {@link VariableSizeEncoder}.\n *\n * @returns A fully functional `Encoder` with both `write` and `encode` methods.\n *\n * @example\n * Creating a custom fixed-size encoder.\n * ```ts\n * const encoder = createEncoder({\n *     fixedSize: 4,\n *     write: (value: number, bytes, offset) => {\n *         bytes.set(new Uint8Array([value]), offset);\n *         return offset + 4;\n *     },\n * });\n *\n * const bytes = encoder.encode(42);\n * // 0x2a000000\n * ```\n *\n * @example\n * Creating a custom variable-size encoder:\n * ```ts\n * const encoder = createEncoder({\n *     getSizeFromValue: (value: string) => value.length,\n *     write: (value: string, bytes, offset) => {\n *         const encodedValue = new TextEncoder().encode(value);\n *         bytes.set(encodedValue, offset);\n *         return offset + encodedValue.length;\n *     },\n * });\n *\n * const bytes = encoder.encode(\"hello\");\n * // 0x68656c6c6f\n * ```\n *\n * @remarks\n * Note that, while `createEncoder` is useful for defining more complex encoders, it is more common to compose\n * encoders together using the various helpers and primitives of the `@solana/codecs` package.\n *\n * Here are some alternative examples using codec primitives instead of `createEncoder`.\n *\n * ```ts\n * // Fixed-size encoder for unsigned 32-bit integers.\n * const encoder = getU32Encoder();\n * const bytes = encoder.encode(42);\n * // 0x2a000000\n *\n * // Variable-size encoder for 32-bytes prefixed UTF-8 strings.\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * const bytes = encoder.encode(\"hello\");\n * // 0x0500000068656c6c6f\n *\n * // Variable-size encoder for custom objects.\n * type Person = { name: string; age: number };\n * const encoder: Encoder<Person> = getStructEncoder([\n *     ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n *     ['age', getU32Encoder()],\n * ]);\n * const bytes = encoder.encode({ name: \"Bob\", age: 42 });\n * // 0x03000000426f622a000000\n * ```\n *\n * @see {@link Encoder}\n * @see {@link FixedSizeEncoder}\n * @see {@link VariableSizeEncoder}\n * @see {@link getStructEncoder}\n * @see {@link getU32Encoder}\n * @see {@link getUtf8Encoder}\n * @see {@link addEncoderSizePrefix}\n */\nexport function createEncoder<TFrom, TSize extends number>(\n    encoder: Omit<FixedSizeEncoder<TFrom, TSize>, 'encode'>,\n): FixedSizeEncoder<TFrom, TSize>;\nexport function createEncoder<TFrom>(encoder: Omit<VariableSizeEncoder<TFrom>, 'encode'>): VariableSizeEncoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom> {\n    return Object.freeze({\n        ...encoder,\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, encoder));\n            encoder.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\n/**\n * Creates a `Decoder` by filling in the missing `decode` function using the provided `read` function.\n *\n * Instead of manually implementing `decode`, this utility leverages the existing `read` function\n * and the size properties to generate a complete decoder. The provided `decode` method will read\n * from a `Uint8Array` at the given offset and return the decoded value.\n *\n * If the `fixedSize` property is provided, a {@link FixedSizeDecoder} will be created, otherwise\n * a {@link VariableSizeDecoder} will be created.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size decoders).\n *\n * @param decoder - A decoder object that implements `read`, but not `decode`.\n * - If the decoder has a `fixedSize` property, it is treated as a {@link FixedSizeDecoder}.\n * - Otherwise, it is treated as a {@link VariableSizeDecoder}.\n *\n * @returns A fully functional `Decoder` with both `read` and `decode` methods.\n *\n * @example\n * Creating a custom fixed-size decoder.\n * ```ts\n * const decoder = createDecoder({\n *     fixedSize: 4,\n *     read: (bytes, offset) => {\n *         const value = bytes[offset];\n *         return [value, offset + 4];\n *     },\n * });\n *\n * const value = decoder.decode(new Uint8Array([42, 0, 0, 0]));\n * // 42\n * ```\n *\n * @example\n * Creating a custom variable-size decoder:\n * ```ts\n * const decoder = createDecoder({\n *     read: (bytes, offset) => {\n *         const decodedValue = new TextDecoder().decode(bytes.subarray(offset));\n *         return [decodedValue, bytes.length];\n *     },\n * });\n *\n * const value = decoder.decode(new Uint8Array([104, 101, 108, 108, 111]));\n * // \"hello\"\n * ```\n *\n * @remarks\n * Note that, while `createDecoder` is useful for defining more complex decoders, it is more common to compose\n * decoders together using the various helpers and primitives of the `@solana/codecs` package.\n *\n * Here are some alternative examples using codec primitives instead of `createDecoder`.\n *\n * ```ts\n * // Fixed-size decoder for unsigned 32-bit integers.\n * const decoder = getU32Decoder();\n * const value = decoder.decode(new Uint8Array([42, 0, 0, 0]));\n * // 42\n *\n * // Variable-size decoder for 32-bytes prefixed UTF-8 strings.\n * const decoder = addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder());\n * const value = decoder.decode(new Uint8Array([5, 0, 0, 0, 104, 101, 108, 108, 111]));\n * // \"hello\"\n *\n * // Variable-size decoder for custom objects.\n * type Person = { name: string; age: number };\n * const decoder: Decoder<Person> = getStructDecoder([\n *     ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n *     ['age', getU32Decoder()],\n * ]);\n * const value = decoder.decode(new Uint8Array([3, 0, 0, 0, 66, 111, 98, 42, 0, 0, 0]));\n * // { name: \"Bob\", age: 42 }\n * ```\n *\n * @see {@link Decoder}\n * @see {@link FixedSizeDecoder}\n * @see {@link VariableSizeDecoder}\n * @see {@link getStructDecoder}\n * @see {@link getU32Decoder}\n * @see {@link getUtf8Decoder}\n * @see {@link addDecoderSizePrefix}\n */\nexport function createDecoder<TTo, TSize extends number>(\n    decoder: Omit<FixedSizeDecoder<TTo, TSize>, 'decode'>,\n): FixedSizeDecoder<TTo, TSize>;\nexport function createDecoder<TTo>(decoder: Omit<VariableSizeDecoder<TTo>, 'decode'>): VariableSizeDecoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo> {\n    return Object.freeze({\n        ...decoder,\n        decode: (bytes, offset = 0) => decoder.read(bytes, offset)[0],\n    });\n}\n\n/**\n * Creates a `Codec` by filling in the missing `encode` and `decode` functions using the provided `write` and `read` functions.\n *\n * This utility combines the behavior of {@link createEncoder} and {@link createDecoder} to produce a fully functional `Codec`.\n * The `encode` method is derived from the `write` function, while the `decode` method is derived from the `read` function.\n *\n * If the `fixedSize` property is provided, a {@link FixedSizeCodec} will be created, otherwise\n * a {@link VariableSizeCodec} will be created.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size codecs).\n *\n * @param codec - A codec object that implements `write` and `read`, but not `encode` or `decode`.\n * - If the codec has a `fixedSize` property, it is treated as a {@link FixedSizeCodec}.\n * - Otherwise, it is treated as a {@link VariableSizeCodec}.\n *\n * @returns A fully functional `Codec` with `write`, `read`, `encode`, and `decode` methods.\n *\n * @example\n * Creating a custom fixed-size codec.\n * ```ts\n * const codec = createCodec({\n *     fixedSize: 4,\n *     read: (bytes, offset) => {\n *         const value = bytes[offset];\n *         return [value, offset + 4];\n *     },\n *     write: (value: number, bytes, offset) => {\n *         bytes.set(new Uint8Array([value]), offset);\n *         return offset + 4;\n *     },\n * });\n *\n * const bytes = codec.encode(42);\n * // 0x2a000000\n * const value = codec.decode(bytes);\n * // 42\n * ```\n *\n * @example\n * Creating a custom variable-size codec:\n * ```ts\n * const codec = createCodec({\n *     getSizeFromValue: (value: string) => value.length,\n *     read: (bytes, offset) => {\n *         const decodedValue = new TextDecoder().decode(bytes.subarray(offset));\n *         return [decodedValue, bytes.length];\n *     },\n *     write: (value: string, bytes, offset) => {\n *         const encodedValue = new TextEncoder().encode(value);\n *         bytes.set(encodedValue, offset);\n *         return offset + encodedValue.length;\n *     },\n * });\n *\n * const bytes = codec.encode(\"hello\");\n * // 0x68656c6c6f\n * const value = codec.decode(bytes);\n * // \"hello\"\n * ```\n *\n * @remarks\n * This function effectively combines the behavior of {@link createEncoder} and {@link createDecoder}.\n * If you only need to encode or decode (but not both), consider using those functions instead.\n *\n * Here are some alternative examples using codec primitives instead of `createCodec`.\n *\n * ```ts\n * // Fixed-size codec for unsigned 32-bit integers.\n * const codec = getU32Codec();\n * const bytes = codec.encode(42);\n * // 0x2a000000\n * const value = codec.decode(bytes);\n * // 42\n *\n * // Variable-size codec for 32-bytes prefixed UTF-8 strings.\n * const codec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * const bytes = codec.encode(\"hello\");\n * // 0x0500000068656c6c6f\n * const value = codec.decode(bytes);\n * // \"hello\"\n *\n * // Variable-size codec for custom objects.\n * type Person = { name: string; age: number };\n * const codec: Codec<PersonInput, Person> = getStructCodec([\n *     ['name', addCodecSizePrefix(getUtf8Codec(), getU32Codec())],\n *     ['age', getU32Codec()],\n * ]);\n * const bytes = codec.encode({ name: \"Bob\", age: 42 });\n * // 0x03000000426f622a000000\n * const value = codec.decode(bytes);\n * // { name: \"Bob\", age: 42 }\n * ```\n *\n * @see {@link Codec}\n * @see {@link FixedSizeCodec}\n * @see {@link VariableSizeCodec}\n * @see {@link createEncoder}\n * @see {@link createDecoder}\n * @see {@link getStructCodec}\n * @see {@link getU32Codec}\n * @see {@link getUtf8Codec}\n * @see {@link addCodecSizePrefix}\n */\nexport function createCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number>(\n    codec: Omit<FixedSizeCodec<TFrom, TTo, TSize>, 'decode' | 'encode'>,\n): FixedSizeCodec<TFrom, TTo, TSize>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec: Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo> {\n    return Object.freeze({\n        ...codec,\n        decode: (bytes, offset = 0) => codec.read(bytes, offset)[0],\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, codec));\n            codec.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\n/**\n * Determines whether the given codec, encoder, or decoder is fixed-size.\n *\n * A fixed-size object is identified by the presence of a `fixedSize` property.\n * If this property exists, the object is considered a {@link FixedSizeCodec},\n * {@link FixedSizeEncoder}, or {@link FixedSizeDecoder}.\n * Otherwise, it is assumed to be a {@link VariableSizeCodec},\n * {@link VariableSizeEncoder}, or {@link VariableSizeDecoder}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @returns `true` if the object is fixed-size, `false` otherwise.\n *\n * @example\n * Checking a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * isFixedSize(encoder); // true\n * ```\n *\n * @example\n * Checking a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * isFixedSize(encoder); // false\n * ```\n *\n * @remarks\n * This function is commonly used to distinguish between fixed-size and variable-size objects at runtime.\n * If you need to enforce this distinction with type assertions, consider using {@link assertIsFixedSize}.\n *\n * @see {@link assertIsFixedSize}\n */\nexport function isFixedSize<TFrom, TSize extends numbe